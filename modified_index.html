<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Agentic Demo Viewer - Strands Integration</title>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.14/dist/hls.min.js"></script>
  <style>
    :root { --panel-bg: rgba(10,10,10,0.7); --accent: #36d38c; --text: #e9eef3; }
    html,body { height: 100%; margin: 0; background: #000; color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}
    #container { position: relative; width: 100%; height: 100%; display: grid; place-items: center; }
    video { width: 100%; height: 100%; object-fit: contain; background: #000; }
    #toast { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); background: var(--panel-bg); color: var(--text); padding: 10px 14px; border-radius: 8px; font-size: 13px; border: 1px solid rgba(255,255,255,0.08); opacity: 0; transition: opacity 200ms ease-in-out; }
    #toast.show { opacity: 1; }

    /* Control Panel with Tabs (left side) */
    .panel {
      position: absolute;
      top: 16px;
      left: 16px;
      z-index: 5;
      background: var(--panel-bg);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      width: 380px;
      max-height: 72vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      backdrop-filter: blur(2px);
    }
    .tabs { display: flex; }
    .tab-btn {
      flex: 1;
      background: transparent;
      color: var(--text);
      border: none;
      padding: 8px 10px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.3px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .tab-btn.active {
      color: var(--accent);
      border-bottom: 2px solid var(--accent);
      background: rgba(54,211,140,0.08);
    }
    .tab { display: none; padding: 10px 12px; overflow: auto; max-height: 60vh; }
    .tab.active { display: block; }
    
    /* Persona card styles */
    .persona-card { border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; background: rgba(15,15,15,0.6); overflow: hidden; margin-bottom: 12px; }
    .persona-summary { padding: 12px; cursor: pointer; transition: background 200ms; }
    .persona-summary:hover { background: rgba(54,211,140,0.05); }
    .persona-name { font-weight: 700; font-size: 16px; color: var(--accent); letter-spacing: 0.5px; }
    .persona-tagline { font-size: 13px; color: #9fb0c0; margin-top: 4px; }
    .persona-details { max-height: 0; overflow: hidden; transition: max-height 300ms ease; }
    .persona-details.expanded { max-height: 500px; }
    .persona-section { padding: 10px 12px; border-top: 1px solid rgba(255,255,255,0.06); }
    .section-title { font-size: 11px; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; font-weight: 600; margin-bottom: 6px; }
    .section-text { font-size: 13px; color: var(--text); line-height: 1.4; }

    /* Turn Control styles */
    .turn-control {
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 8px;
      background: rgba(15,15,15,0.6);
      padding: 12px;
      margin-bottom: 12px;
    }
    .turn-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .turn-title { font-weight: 700; font-size: 14px; color: var(--accent); }
    .turn-status {
      font-size: 11px;
      font-weight: 600;
      padding: 2px 6px;
      border-radius: 4px;
      text-transform: uppercase;
    }
    .status-ready { background: rgba(54,211,140,0.2); color: var(--accent); }
    .status-running { background: rgba(255,193,7,0.2); color: #ffc107; }
    .status-completed { background: rgba(40,167,69,0.2); color: #28a745; }
    .status-error { background: rgba(220,53,69,0.2); color: #dc3545; }

    .prompt-input {
      width: 85%;
      background: #0b1b26;
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--text);
      border-radius: 6px;
      padding: 8px 10px;
      font-size: 13px;
      margin: 0 auto 8px auto;
      display: block;
      resize: vertical;
      min-height: 40px;
    }
    .turn-actions {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      justify-content: center;
    }
    .run-turn-btn {
      background: var(--accent);
      color: #0b1b26;
      border: none;
      border-radius: 6px;
      padding: 8px 16px;
      font-weight: 600;
      cursor: pointer;
      flex: 1;
      font-size: 14px;
    }
    .run-turn-btn:disabled {
      background: #666;
      cursor: not-allowed;
    }
    .persona-select {
      background: #0b1b26;
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--text);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 12px;
      flex: 1;
    }

    .turn-result {
      background: rgba(5,5,5,0.8);
      border-radius: 6px;
      padding: 10px;
      margin-top: 8px;
      max-height: 200px;
      overflow-y: auto;
    }
    .result-text {
      font-size: 13px;
      color: var(--text);
      line-height: 1.4;
      margin-bottom: 8px;
    }
    .result-meta {
      font-size: 11px;
      color: #9fb0c0;
      border-top: 1px solid rgba(255,255,255,0.06);
      padding-top: 6px;
    }
    .s3-link {
      color: var(--accent);
      text-decoration: none;
      margin-right: 12px;
    }
    .s3-link:hover { text-decoration: underline; }

    /* Stream of consciousness styles */
    .consciousness-stream { height: 100%; display: flex; flex-direction: column; }
    .stream-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-bottom: 1px solid rgba(255,255,255,0.08); }
    .stream-title { font-size: 13px; font-weight: 600; color: var(--text); }
    .stream-status { font-size: 11px; color: #ef4444; font-weight: 600; }
    
    /* Queue Status styles */
    .queue-status { border-bottom: 1px solid rgba(255,255,255,0.08); background: rgba(5,5,5,0.4); }
    .queue-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; cursor: pointer; }
    .queue-title { font-size: 12px; font-weight: 600; color: #f59e0b; }
    .toggle-queue { background: none; border: none; color: var(--text); font-size: 12px; cursor: pointer; }
    .currently-processing { padding: 6px 12px; border-bottom: 1px solid rgba(255,255,255,0.04); background: rgba(255,193,7,0.1); }
    .processing-label { font-size: 11px; color: #ffc107; font-weight: 600; margin-bottom: 4px; }
    .processing-message { font-size: 12px; color: var(--text); font-style: italic; }
    .queue-list { max-height: 120px; overflow-y: auto; }
    .queue-item { padding: 4px 12px; font-size: 11px; color: #9fb0c0; border-bottom: 1px solid rgba(255,255,255,0.02); }
    .queue-empty { padding: 6px 12px; font-size: 11px; color: #666; font-style: italic; }
    .stream-content { flex: 1; padding: 12px; overflow-y: auto; max-height: 50vh; background: rgba(5,5,5,0.8); border-radius: 6px; margin: 8px; }
    .stream-line { font-size: 13px; color: var(--text); line-height: 1.5; font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace; margin-bottom: 8px; white-space: pre-wrap; word-break: break-word; }
    .stream-thought { color: #a855f7; font-style: italic; }
    .stream-response { color: #36d38c; font-weight: 500; }
    .stream-tool { color: #f59e0b; }
    .stream-historical { opacity: 0.7; border-left: 2px solid rgba(255,255,255,0.1); padding-left: 8px; margin-left: 4px; }
    .cursor { display: inline-block; width: 2px; height: 1em; background: var(--accent); animation: blink 1s infinite; margin-left: 2px; }
    @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }

    /* History styles */
    .history-item {
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 6px;
      background: rgba(5,5,5,0.4);
    }
    .history-prompt {
      font-size: 12px;
      color: #9fb0c0;
      margin-bottom: 4px;
    }
    .history-response {
      font-size: 13px;
      color: var(--text);
      margin-bottom: 4px;
    }
    .history-meta {
      font-size: 11px;
      color: #666;
    }
  </style>
</head>
<body>
 <div id="container">
   <video id="player" playsinline muted autoplay></video>
   <div id="toast"></div>

   <!-- Control panel with tabs -->
   <div id="controlPanel" class="panel" aria-label="Control panel">
     <div class="tabs">
       <button class="tab-btn active" data-tab="t-control">Agent Control</button>
       <button class="tab-btn" data-tab="t-persona">Persona</button>
       <button class="tab-btn" data-tab="t-stream">Stream</button>
     </div>

     <!-- Agent Control Tab -->
     <div id="t-control" class="tab active">
       <div class="turn-control">
         <div class="turn-header">
           <div class="turn-title">Strands Agent Control</div>
           <div id="turnStatus" class="turn-status status-ready">Ready</div>
         </div>
         
         <textarea id="promptInput" class="prompt-input" placeholder="Send the agent a message"></textarea>
         
         <div class="turn-actions">
           <button id="runTurnBtn" class="run-turn-btn">‚ñ∂Ô∏è Run Turn</button>
         </div>

         <div id="turnResult" class="turn-result" style="display: none;">
           <div id="resultText" class="result-text"></div>
           <div id="resultMeta" class="result-meta"></div>
         </div>
       </div>
     </div>

     <!-- Persona Tab -->
     <div id="t-persona" class="tab">
       <div class="persona-card">
         <div class="persona-summary" onclick="togglePersona()">
           <div class="persona-name">ALEX - URBAN PHILOSOPHER</div>
           <div class="persona-tagline">26-year-old NYC resident exploring with philosophical curiosity ‚Üï</div>
         </div>
         <div id="persona-details" class="persona-details">
           <div class="persona-section">
             <div class="section-title">Character Profile</div>
             <div id="currentPersonaText" class="section-text">Alex - 26-year-old NYC philosopher who sees deeper meaning in everyday experiences</div>
           </div>
           <div class="persona-section">
             <div class="section-title">Background</div>
             <div class="section-text">Philosophy degree graduate living in New York City. Currently outside exploring the urban landscape with curiosity and wonder.</div>
           </div>
           <div class="persona-section">
             <div class="section-title">Personality Traits</div>
             <div class="section-text">Frequently philosophizes about life, human nature, and meaning of everyday experiences. Sees deeper connections in mundane things. References philosophical concepts in conversation.</div>
           </div>
           <div class="persona-section">
             <div class="section-title">System Integration</div>
             <div class="section-text">Real-time character embodiment ‚Ä¢ Unreal Engine movement ‚Ä¢ Environmental awareness ‚Ä¢ Philosophical commentary</div>
           </div>
         </div>
       </div>
     </div>

     <!-- Stream Tab -->
     <div id="t-stream" class="tab">
       <div class="consciousness-stream">
         <div class="stream-header">
           <div class="stream-title">Agent Thoughts</div>
           <div id="streamStatus" class="stream-status">‚óè Waiting</div>
         </div>
         
         <!-- Queue Status -->
         <div id="queueStatus" class="queue-status" style="display: none;">
           <div class="queue-header">
             <span class="queue-title">Processing Queue</span>
             <button id="toggleQueue" class="toggle-queue">‚ñº</button>
           </div>
           <div id="currentlyProcessing" class="currently-processing" style="display: none;">
             <div class="processing-label">üîÑ Currently Processing:</div>
             <div id="processingMessage" class="processing-message"></div>
           </div>
           <div id="queueList" class="queue-list">
             <div class="queue-empty">No messages in queue</div>
           </div>
         </div>
         
         <div class="stream-content" id="streamContent">
           <div class="stream-line">Strands agent ready. Click "Run Turn" to begin...</div>
         </div>
       </div>
     </div>

   </div>
 </div>
 
<script>
(function() {
  const video = document.getElementById('player');
  const toast = document.getElementById('toast');
  function showToast(msg) { 
    toast.textContent = msg; 
    toast.classList.add('show'); 
    setTimeout(() => toast.classList.remove('show'), 2500); 
  }

  // Strands Agent Integration
  class StrandsAgentClient {
    constructor() {
      // Use remote API server
      this.apiUrl = 'https://api.thedimessquare.com';
      this.websocket = null;
      this.sessionId = this.generateSessionId();
      this.currentTurn = null;
      this.turnHistory = [];
      this.isConnected = false;
      
      // Streaming buffer for smooth display
      this.streamBuffer = ''; 
      this.currentStreamElement = null; 
      this.streamStartTime = null;
      this.lastDisplayedResponse = null;
      
      // Queue management
      this.queueData = {
        currentlyProcessing: null,
        queue: [],
        isQueueExpanded: false
      };
      
      // Debouncing for streaming
      this.pendingChunk = '';
      this.flushTimer = null;
    }

    generateSessionId() {
      const key = 'strandsSessionId';
      let v = sessionStorage.getItem(key);
      if (!v) {
        v = 'strands-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        sessionStorage.setItem(key, v);
      }
      return v;
    }

    async startTurn(prompt, persona = 'urban_philosopher') {
      const personas = {
        urban_philosopher: {
          persona: "You are Alex, a 26-year-old living in New York City. You're currently outside exploring the urban landscape. You have a philosophy degree and frequently philosophize about life, human nature, and the meaning of everyday experiences. You tend to see deeper connections in mundane things and often reference philosophical concepts in casual conversation. You move through the world with curiosity and wonder."
        },
        street_artist: {
          persona: "You are Sam, a 28-year-old street artist from Brooklyn. You're outside looking for inspiration and new spots for your art. You see the city as your canvas and are always observing colors, textures, and urban beauty that others might miss. You have strong opinions about creativity, authenticity, and how art can change communities. You speak with passion about your craft."
        },
        night_wanderer: {
          persona: "You are River, a 24-year-old insomniac who finds peace in late-night city walks. You're outside during the quiet hours, observing how different the world feels after dark. You're introspective and melancholic, finding beauty in solitude and empty streets. You often think about what people's lives are like behind lit windows and wonder about the stories of strangers."
        },
        urban_explorer: {
          persona: "You are Casey, a 30-year-old urban explorer and photographer. You're outside searching for abandoned places, rooftops, and hidden corners of the city that most people never see. You're fearless about climbing and exploring, driven by curiosity about forgotten spaces and untold stories. You document everything and love sharing discoveries with others."
        }
      };

      try {
        const response = await fetch(`${this.apiUrl}/api/add_command`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: prompt,
            persona_traits: personas[persona] || personas.urban_philosopher,
            submitted_by: 'frontend'
          })
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();
        this.currentTurn = result;
        return result;
      } catch (error) {
        console.error('Failed to start turn:', error);
        throw error;
      }
    }

    async getTurnStatus(turnId) {
      try {
        const response = await fetch(`${this.apiUrl}/api/turn_status/${turnId}`);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
      } catch (error) {
        console.error('Failed to get turn status:', error);
        throw error;
      }
    }

    connectWebSocket() {
      if (!this.apiUrl) {
        console.log('API URL not configured, skipping WebSocket');
        this.updateStreamStatus('API not configured');
        return;
      }

      // Close existing WebSocket if any
      if (this.websocket) {
        this.websocket.close();
      }

      // Enable WebSocket connections
      try {
        const wsUrl = this.apiUrl.replace('https://', 'wss://').replace('http://', 'ws://');
        console.log('Connecting to WebSocket:', `${wsUrl}/ws`);
        this.websocket = new WebSocket(`${wsUrl}/ws`);  // Global WebSocket for shared agent
        
        this.websocket.onopen = () => {
          console.log('WebSocket connected to Strands API');
          this.isConnected = true;
          this.updateStreamStatus('Connected');
          
          // Load recent agent thoughts on connect
          this.loadRecentThoughts();
        };

        this.websocket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            this.handleWebSocketMessage(data);
          } catch (error) {
            console.error('Failed to parse WebSocket message:', error);
          }
        };

        this.websocket.onclose = () => {
          console.log('WebSocket disconnected');
          this.isConnected = false;
          this.updateStreamStatus('Disconnected');
          // Retry connection after 5 seconds
          setTimeout(() => this.connectWebSocket(), 5000);
        };

        this.websocket.onerror = (error) => {
          console.error('WebSocket error:', error);
          this.updateStreamStatus('Error');
        };
      } catch (error) {
        console.error('Failed to connect WebSocket:', error);
        this.updateStreamStatus('Failed to connect');
      }
    }

    handleWebSocketMessage(data) {
      switch(data.type) {
        case 'turn_update':
        case 'status_update':
          this.updateTurnDisplay(data.data);
          break;
        case 'initial_status':
          this.addToStream(`üü¢ Connected to shared agent (${data.connected_clients} clients)`);
          break;
        case 'command_queued':
          this.addToStream(`üìù Command queued: ${data.command.prompt}`);
          this.queueData.queue.push({
            id: data.command.command_id,
            prompt: data.command.prompt,
            timestamp: new Date().toLocaleTimeString()
          });
          this.updateQueueDisplay();
          this.updateTurnDisplay({status: 'pending', turn_id: data.command.command_id});
          break;
        case 'command_started':
          this.finalizeStreaming(); // End any previous streaming
          this.addToStream(`üöÄ Processing command: ${data.command.prompt}`);
          // Move from queue to currently processing
          this.queueData.currentlyProcessing = {
            id: data.command.command_id,
            prompt: data.command.prompt,
            timestamp: new Date().toLocaleTimeString()
          };
          this.queueData.queue = this.queueData.queue.filter(q => q.id !== data.command.command_id);
          this.updateQueueDisplay();
          this.updateTurnDisplay({status: 'processing', turn_id: data.command.command_id});
          break;
        case 'command_progress':
          if (data.message) {
            this.addToStream(`‚ö° ${data.message}`);
          }
          break;
        case 'command_completed':
          this.finalizeStreaming(); // End any streaming before completion message
          this.addToStream(`‚úÖ Command completed!`);
          this.queueData.currentlyProcessing = null; // Clear currently processing
          this.updateQueueDisplay();
          this.updateTurnDisplay(data.result);
          break;
        case 'command_error':
          this.addToStream(`‚ùå Command failed: ${data.error}`);
          this.queueData.currentlyProcessing = null; // Clear currently processing on error
          this.updateQueueDisplay();
          this.updateTurnDisplay({status: 'error', error_message: data.error});
          break;
        case 'agent_thought':
          this.addToStream(`üí≠ ${data.content}`, 'thought');
          break;
        case 'agent_response':
          this.handleStreamingResponse(data.content);
          break;
        case 'agent_response_complete':
          this.finalizeStreaming();
          break;
        case 'tool_use':
          this.addToStream(`üîß Tool #${data.tool_number}: ${data.tool_name}`, 'tool');
          break;
        case 'pong':
          // Keep-alive response
          break;
        default:
          console.log('Unknown WebSocket message:', data);
      }
    }

    updateTurnDisplay(turnData) {
      if (!turnData) return;
      
      const statusEl = document.getElementById('turnStatus');
      const resultEl = document.getElementById('turnResult');
      const resultText = document.getElementById('resultText');
      const resultMeta = document.getElementById('resultMeta');

      if (turnData.status) {
        statusEl.textContent = turnData.status.charAt(0).toUpperCase() + turnData.status.slice(1);
        statusEl.className = `turn-status status-${turnData.status}`;
      }

      // Stream agent response in chunks for better UX
      if (turnData.agent_response && turnData.agent_response !== this.lastDisplayedResponse) {
        this.lastDisplayedResponse = turnData.agent_response;
        
        // Add full response to stream
        this.addToStream(`Agent: ${turnData.agent_response.substring(0, 200)}${turnData.agent_response.length > 200 ? '...' : ''}`);
        
        // Show position updates
        if (turnData.env_state && turnData.env_state.pos) {
          const pos = turnData.env_state.pos;
          this.addToStream(`Position: (${pos[0].toFixed(1)}, ${pos[1].toFixed(1)}, ${pos[2].toFixed(1)})`);
        }
      }

      if (turnData.status === 'completed' && turnData.agent_response) {
        resultText.textContent = turnData.agent_response;
        
        let metaHtml = `Turn: ${turnData.turn_id} ‚Ä¢ ${turnData.timestamp}`;
        if (turnData.s3_urls) {
          if (turnData.s3_urls.screenshot) {
            metaHtml += `<br><a href="${turnData.s3_urls.screenshot}" target="_blank" class="s3-link">üì∏ Screenshot</a>`;
          }
          if (turnData.s3_urls.env_state) {
            metaHtml += `<a href="${turnData.s3_urls.env_state}" target="_blank" class="s3-link">üìä State</a>`;
          }
          if (turnData.s3_urls.turn_data) {
            metaHtml += `<a href="${turnData.s3_urls.turn_data}" target="_blank" class="s3-link">üìÑ Data</a>`;
          }
        }
        resultMeta.innerHTML = metaHtml;
        resultEl.style.display = 'block';

        // Add to history
        this.turnHistory.unshift({
          prompt: turnData.prompt,
          response: turnData.agent_response,
          timestamp: turnData.timestamp,
          turnId: turnData.turn_id,
          s3_urls: turnData.s3_urls
        });
        this.updateHistoryDisplay();

        // Update stream with completion
        this.addToStream(`‚úÖ Turn completed successfully!`);
      } else if (turnData.status === 'error') {
        resultText.textContent = `Error: ${turnData.error_message || 'Unknown error occurred'}`;
        resultMeta.textContent = `Turn: ${turnData.turn_id} ‚Ä¢ Failed`;
        resultEl.style.display = 'block';
        this.addToStream(`‚ùå Turn failed: ${turnData.error_message}`);
      } else if (turnData.status === 'running') {
        this.addToStream('üîÑ Agent is thinking...');
      } else if (turnData.status === 'pending') {
        this.addToStream('‚è≥ Turn starting...');
      }
    }

    updateQueueDisplay() {
      const queueStatus = document.getElementById('queueStatus');
      const currentlyProcessing = document.getElementById('currentlyProcessing');
      const processingMessage = document.getElementById('processingMessage');
      const queueList = document.getElementById('queueList');
      
      // Show/hide queue status section
      const hasActivity = this.queueData.currentlyProcessing || this.queueData.queue.length > 0;
      queueStatus.style.display = hasActivity ? 'block' : 'none';
      
      // Update currently processing section
      if (this.queueData.currentlyProcessing) {
        currentlyProcessing.style.display = 'block';
        processingMessage.textContent = `"${this.queueData.currentlyProcessing.prompt.substring(0, 60)}${this.queueData.currentlyProcessing.prompt.length > 60 ? '...' : ''}"`;
      } else {
        currentlyProcessing.style.display = 'none';
      }
      
      // Update queue list
      if (this.queueData.queue.length > 0) {
        queueList.innerHTML = this.queueData.queue.map((item, index) => 
          `<div class="queue-item">${index + 1}. "${item.prompt.substring(0, 50)}${item.prompt.length > 50 ? '...' : ''}" (${item.timestamp})</div>`
        ).join('');
      } else {
        queueList.innerHTML = '<div class="queue-empty">No messages in queue</div>';
      }
    }

    updateStreamStatus(status) {
      const statusEl = document.getElementById('streamStatus');
      if (statusEl) {
        statusEl.textContent = `‚óè ${status}`;
        statusEl.style.color = this.isConnected ? '#36d38c' : '#ef4444';
      }
    }

    addToStream(message, type = null) {
      const streamContent = document.getElementById('streamContent');
      const streamLine = document.createElement('div');
      streamLine.className = 'stream-line';
      if (type) {
        streamLine.className += ` stream-${type}`;
      }
      streamLine.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      streamContent.appendChild(streamLine);

      // Keep only last 50 messages
      while (streamContent.children.length > 50) {
        streamContent.removeChild(streamContent.firstChild);
      }
    }

    handleStreamingResponse(content) {
      // 0) Basic guards
      if (typeof content !== 'string' || !content) return;

      // 1) Normalize incoming to avoid false mismatches
      let incoming = content
        .replace(/[\u200B-\u200D\uFEFF]/g, '') // zero-widths
        .replace(/\r\n?/g, '\n');              // CRLF ‚Üí LF

      // 2) Debounce micro-chunks to avoid "* l *" flicker
      this.pendingChunk += incoming;
      if (this.flushTimer) return;
      this.flushTimer = setTimeout(() => {
        const chunk = this.pendingChunk;
        this.pendingChunk = '';
        this.flushTimer = null;

        const streamContent = document.getElementById('streamContent');

        // Start line if needed
        if (!this.currentStreamElement) {
          this.currentStreamElement = document.createElement('div');
          this.currentStreamElement.className = 'stream-line stream-response';
          this.streamStartTime = new Date().toLocaleTimeString();
          this.currentStreamElement.textContent = `[${this.streamStartTime}] ü§ñ `;
          this.streamBuffer = '';
          streamContent.appendChild(this.currentStreamElement);
        }

        // 3) Fast path: if the whole chunk already appears near the end, skip (echo)
        const recent = this.streamBuffer.slice(-2000);
        if (recent.includes(chunk)) {
          // exact echo of a recent slice; ignore
          return;
        }

        // 4) Robust overlap merge (handles cumulative & partial deltas)
        let segment = chunk;
        if (this.streamBuffer.length > 0) {
          const searchWindow = this.streamBuffer.slice(-2000); // windowed for perf
          // (a) if our search window is a strict prefix of the new segment, catch that
          if (segment.startsWith(searchWindow)) {
            segment = segment.slice(searchWindow.length);
          } else {
            // (b) general suffix(prefix) overlap
            const maxOverlap = Math.min(1000, searchWindow.length, segment.length);
            let overlap = 0;
            for (let i = maxOverlap; i > 0; i--) {
              if (searchWindow.endsWith(segment.slice(0, i))) { overlap = i; break; }
            }
            segment = segment.slice(overlap);
          }
        }

        // 5) Append (no boundary-space heuristic; avoids "embedde d")
        this.streamBuffer += segment;

        // 6) Light punctuation spacing (preserves ellipses)
        this.streamBuffer = this.streamBuffer
          .replace(/([.!?])(?![.!?])(\S)/g, '$1 $2')   // "word.Word" ‚Üí "word. Word" but keeps "..." intact
          .replace(/([,;:])(?![,;:])(\S)/g, '$1 $2')   // "word,Word" ‚Üí "word, Word" but keeps ",," intact
          .replace(/\*(\S)/g, '* $1')                  // "*word" ‚Üí "* word"
          .replace(/(\S)\*/g, '$1 *');                 // "word*" ‚Üí "word *"

        // 7) Render
        this.currentStreamElement.textContent = `[${this.streamStartTime}] ü§ñ ${this.streamBuffer}`;

        // Optional: split long lines
        if (this.streamBuffer.includes('. ') && this.streamBuffer.length > 200) {
          this.finalizeStreaming();
        }
      }, 50); // 40‚Äì60ms is a sweet spot
    }

    finalizeStreaming() {
      // Close any active streaming element
      if (this.currentStreamElement) {
        this.currentStreamElement = null;
        this.streamBuffer = '';
        this.streamStartTime = null;
      }
    }

    async loadRecentThoughts() {
      try {
        const response = await fetch(`${this.apiUrl}/api/thoughts?limit=20`);
        const data = await response.json();
        
        if (data.thoughts && data.thoughts.length > 0) {
          this.addToStream(`üìã Loading ${data.thoughts.length} recent agent thoughts...`);
          
          // Reverse to show oldest first, then newest
          const thoughts = data.thoughts.reverse();
          
          for (const thought of thoughts) {
            const timestamp = new Date(thought.timestamp).toLocaleTimeString();
            let icon = 'ü§ñ';
            let messageType = 'response';
            
            if (thought.type === 'agent_thought') {
              icon = 'üí≠';
              messageType = 'thought';
            } else if (thought.type === 'tool_use') {
              icon = 'üîß';
              messageType = 'tool';
            }
            
            // Add historical message with original timestamp
            const streamContent = document.getElementById('streamContent');
            const streamLine = document.createElement('div');
            streamLine.className = `stream-line stream-${messageType} stream-historical`;
            streamLine.textContent = `[${timestamp}] ${icon} ${thought.content}`;
            streamContent.appendChild(streamLine);
          }
          
          this.addToStream('üìã Historical thoughts loaded - new messages will appear below');
        }
      } catch (error) {
        console.error('Failed to load recent thoughts:', error);
        this.addToStream('‚ùå Failed to load historical thoughts');
      }
    }

    updateHistoryDisplay() {
      const historyContent = document.getElementById('historyContent');
      if (this.turnHistory.length === 0) {
        historyContent.innerHTML = '<div class="stream-line">Turn history will appear here...</div>';
        return;
      }

      historyContent.innerHTML = this.turnHistory.map(turn => `
        <div class="history-item">
          <div class="history-prompt">Prompt: ${this.escapeHtml(turn.prompt)}</div>
          <div class="history-response">${this.escapeHtml(turn.response)}</div>
          <div class="history-meta">
            ${turn.timestamp} ‚Ä¢ ${turn.turnId}
            ${turn.s3_urls && turn.s3_urls.screenshot ? `‚Ä¢ <a href="${turn.s3_urls.screenshot}" target="_blank" class="s3-link">Screenshot</a>` : ''}
          </div>
        </div>
      `).join('');
    }

    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  }

  // Initialize Strands client
  const strandsClient = new StrandsAgentClient();
  
  // Connect WebSocket
  strandsClient.connectWebSocket();

  // Persona toggle function
  window.togglePersona = function() {
    const details = document.getElementById('persona-details');
    details.classList.toggle('expanded');
  };

  // Update persona display
  function updatePersonaDisplay(persona) {
    const personaInfo = {
      urban_philosopher: {
        name: "ALEX - URBAN PHILOSOPHER",
        tagline: "26-year-old NYC resident exploring with philosophical curiosity ‚Üï",
        profile: "Alex - 26-year-old NYC philosopher who sees deeper meaning in everyday experiences",
        background: "Philosophy degree graduate living in New York City. Currently outside exploring the urban landscape with curiosity and wonder.",
        traits: "Frequently philosophizes about life, human nature, and meaning of everyday experiences. Sees deeper connections in mundane things. References philosophical concepts in conversation."
      },
      street_artist: {
        name: "SAM - STREET ARTIST", 
        tagline: "28-year-old Brooklyn artist seeking urban inspiration ‚Üï",
        profile: "Sam - 28-year-old Brooklyn street artist seeking inspiration and new canvases",
        background: "Creative street artist from Brooklyn who views the city as their canvas. Currently outside looking for new spots and artistic inspiration.",
        traits: "Observes colors, textures, and urban beauty others miss. Strong opinions about creativity, authenticity, and art's power to change communities. Speaks passionately about craft."
      },
      night_wanderer: {
        name: "RIVER - NIGHT WANDERER",
        tagline: "24-year-old insomniac finding beauty in solitude ‚Üï", 
        profile: "River - 24-year-old insomniac finding beauty in solitude and empty city streets",
        background: "Insomniac who finds peace in late-night city walks. Outside during quiet hours, observing how different the world feels after dark.",
        traits: "Introspective and melancholic, finding beauty in solitude. Thinks about lives behind lit windows and wonders about strangers' stories."
      },
      urban_explorer: {
        name: "CASEY - URBAN EXPLORER",
        tagline: "30-year-old photographer exploring hidden city corners ‚Üï",
        profile: "Casey - 30-year-old photographer exploring forgotten places and hidden city corners", 
        background: "Urban explorer and photographer searching for abandoned places, rooftops, and hidden corners most people never see.",
        traits: "Fearless about climbing and exploring, driven by curiosity about forgotten spaces. Documents everything and loves sharing discoveries."
      }
    };
    
    const info = personaInfo[persona] || personaInfo.urban_philosopher;
    
    // Update persona tab elements
    const personaName = document.querySelector('.persona-name');
    const personaTagline = document.querySelector('.persona-tagline');
    const currentPersonaText = document.getElementById('currentPersonaText');
    const backgroundText = document.querySelector('.persona-section:nth-child(2) .section-text');
    const traitsText = document.querySelector('.persona-section:nth-child(3) .section-text');
    
    if (personaName) personaName.textContent = info.name;
    if (personaTagline) personaTagline.textContent = info.tagline;
    if (currentPersonaText) currentPersonaText.textContent = info.profile;
    if (backgroundText) backgroundText.textContent = info.background;
    if (traitsText) traitsText.textContent = info.traits;
  }

  // Wire up Run Turn functionality
  const runTurnBtn = document.getElementById('runTurnBtn');
  const promptInput = document.getElementById('promptInput');

  // Function to switch tabs programmatically
  function switchToTab(tabId) {
    const controlPanel = document.getElementById('controlPanel');
    if (!controlPanel) return;
    
    // Remove active from all tab buttons and tabs
    for (const b of controlPanel.querySelectorAll('.tab-btn')) b.classList.remove('active');
    for (const t of controlPanel.querySelectorAll('.tab')) t.classList.remove('active');
    
    // Find and activate the target tab button
    const targetBtn = controlPanel.querySelector(`[data-tab="${tabId}"]`);
    if (targetBtn) targetBtn.classList.add('active');
    
    // Activate the target tab content
    const tabEl = controlPanel.querySelector('#' + tabId);
    if (tabEl) tabEl.classList.add('active');
  }

  // Function to submit command
  async function submitCommand() {
    const prompt = promptInput.value.trim();
    const persona = 'urban_philosopher'; // Default persona
    
    if (!prompt) {
      showToast('Please enter a message');
      return;
    }

    // Switch to Stream tab immediately
    switchToTab('t-stream');
    
    // Clear input and disable button temporarily
    promptInput.value = '';
    runTurnBtn.disabled = true;
    runTurnBtn.textContent = '‚è≥ Sending...';
    
    try {
      strandsClient.addToStream(`üì§ Sending: ${prompt}`);
      const result = await strandsClient.startTurn(prompt, persona);
      
      // Re-enable button
      runTurnBtn.disabled = false;
      runTurnBtn.textContent = '‚ñ∂Ô∏è Run Turn';
      
      // Update persona display
      updatePersonaDisplay(persona);
      
      // Poll for status updates with faster initial polling
        let pollCount = 0;
        const pollStatus = async () => {
          try {
            const status = await strandsClient.getTurnStatus(result.command_id);
            strandsClient.updateTurnDisplay(status);
            
            if (status.status === 'running' || status.status === 'pending') {
              pollCount++;
              // More frequent polling initially, then slower
              const interval = pollCount < 10 ? 1000 : pollCount < 20 ? 2000 : 3000;
              setTimeout(pollStatus, interval);
            } else {
              runTurnBtn.disabled = false;
              runTurnBtn.textContent = '‚ñ∂Ô∏è Run Turn';
              strandsClient.addToStream(`üèÅ Polling completed after ${pollCount} checks`);
            }
          } catch (error) {
            console.error('Failed to poll status:', error);
            strandsClient.addToStream(`‚ùå Polling error: ${error.message}`);
            runTurnBtn.disabled = false;
            runTurnBtn.textContent = '‚ñ∂Ô∏è Run Turn';
          }
        };
        
        setTimeout(pollStatus, 500); // Start polling quickly
        
      } catch (error) {
        console.error('Turn failed:', error);
        showToast(`Turn failed: ${error.message}`);
        strandsClient.addToStream(`Turn failed: ${error.message}`);
        runTurnBtn.disabled = false;
        runTurnBtn.textContent = '‚ñ∂Ô∏è Run Turn';
      }
    }

  if (runTurnBtn && promptInput) {
    // Click handler
    runTurnBtn.addEventListener('click', submitCommand);
    
    // Enter key handler
    promptInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault(); // Prevent line break
        submitCommand();
      }
    });
  }


  // Video player setup (from original)
  const urlParams = new URLSearchParams(window.location.search);
  const srcParam = urlParams.get('src');
  const defaultLive = 'https://ccf3786b925ee51c.mediapackage.us-east-1.amazonaws.com/out/v1/f7dd6e8b0ee74ff4954fcc90c4e138b8/index.m3u8';
  const fallbackVod = window.location.origin + '/assets/sample.mp4';
  const sources = srcParam ? [srcParam] : [defaultLive, fallbackVod];
  let current = 0;
  function isHls(u) { return /\.m3u8(\?.*)?$/i.test(u); }
  function tryNext() {
    if (current >= sources.length) { showToast('No playable source found'); return; }
    const src = sources[current++];
    if (isHls(src)) {
      if (window.Hls && window.Hls.isSupported()) {
        const hls = new Hls({ lowLatencyMode: false, enableWorker: true });
        hls.on(Hls.Events.ERROR, (e, data) => {
          if (data.fatal) { hls.destroy(); showToast('HLS error, falling back'); tryNext(); }
        });
        hls.loadSource(src);
        hls.attachMedia(video);
      } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
        video.src = src;
      } else {
        showToast('HLS not supported, falling back'); tryNext(); return;
      }
    } else {
      video.src = src;
    }
  }
  video.addEventListener('error', () => { showToast('Playback error, trying next source'); tryNext(); });
  tryNext();

  // Tabs switching
  const controlPanel = document.getElementById('controlPanel');
  if (controlPanel) {
    controlPanel.addEventListener('click', (ev) => {
      const btn = ev.target.closest('.tab-btn');
      if (!btn) return;
      const target = btn.getAttribute('data-tab');
      for (const b of controlPanel.querySelectorAll('.tab-btn')) b.classList.remove('active');
      btn.classList.add('active');
      for (const t of controlPanel.querySelectorAll('.tab')) t.classList.remove('active');
      const tabEl = controlPanel.querySelector('#' + target);
      if (tabEl) tabEl.classList.add('active');
    });
  }

  // Initialize
  strandsClient.addToStream('Strands Agent Client initialized');
  updatePersonaDisplay('urban_philosopher');
  
  // Setup queue toggle functionality
  const queueHeader = document.querySelector('.queue-header');
  const toggleQueue = document.getElementById('toggleQueue');
  const queueList = document.getElementById('queueList');
  
  if (queueHeader && toggleQueue) {
    queueHeader.addEventListener('click', () => {
      strandsClient.queueData.isQueueExpanded = !strandsClient.queueData.isQueueExpanded;
      if (strandsClient.queueData.isQueueExpanded) {
        queueList.style.display = 'block';
        toggleQueue.textContent = '‚ñ≤';
      } else {
        queueList.style.display = 'none';
        toggleQueue.textContent = '‚ñº';
      }
    });
  }

})();
</script>
</body>
</html>